#!/usr/bin/env python3
"""
Gantt Chart Generator from Task-Master Output
Parses task-master.dev generated tasks and creates an interactive Gantt chart
"""

import re
import sys
import json
import pandas as pd
import plotly.graph_objects as go
import plotly.express as px
from datetime import datetime, timedelta
from dataclasses import dataclass
from typing import List, Dict, Optional
import argparse

@dataclass
class Task:
    id: int
    name: str
    description: str
    assigned_to: str
    dependencies: List[int]
    effort: str
    priority: str
    status: str
    start_date: Optional[datetime] = None
    end_date: Optional[datetime] = None
    duration_days: int = 1

class TaskParser:
    """Parse task-master.dev JSON output format"""
    
    def __init__(self):
        self.effort_mapping = {
            'high': 10,
            'medium': 5,
            'low': 2,
            'small': 2,
            'large': 10,
            'extra large': 15,
            'xl': 15
        }
    
    def parse_tasks_from_json(self, content: str) -> List[Task]:
        """Parse tasks from JSON format generated by task-master.dev"""
        try:
            data = json.loads(content)
            tasks = []
            
            # Extract tasks from the master context
            task_data = data.get('master', {}).get('tasks', [])
            
            for task_item in task_data:
                # Map role to a more readable format
                assigned_to = self._extract_assigned_role(task_item.get('title', ''))
                
                # Extract dependencies (assuming they're task IDs)
                dependencies = task_item.get('dependencies', [])
                
                # Determine effort based on priority and description length
                effort = self._determine_effort(task_item)
                
                task = Task(
                    id=task_item.get('id', 0),
                    name=task_item.get('title', ''),
                    description=task_item.get('description', ''),
                    assigned_to=assigned_to,
                    dependencies=dependencies,
                    effort=effort,
                    priority=task_item.get('priority', 'medium'),
                    status=task_item.get('status', 'pending')
                )
                
                tasks.append(task)
            
            return tasks
            
        except json.JSONDecodeError as e:
            print(f"Error parsing JSON: {e}")
            return []
    
    def _extract_assigned_role(self, title: str) -> str:
        """Extract likely assigned role based on task title"""
        title_lower = title.lower()
        
        if any(word in title_lower for word in ['database', 'schema', 'model', 'api', 'backend']):
            return 'Backend Developer'
        elif any(word in title_lower for word in ['frontend', 'component', 'ui', 'react']):
            return 'Frontend Developer'
        elif any(word in title_lower for word in ['deployment', 'ci/cd', 'docker', 'aws', 'infrastructure']):
            return 'DevOps Engineer'
        elif any(word in title_lower for word in ['setup', 'project', 'environment']):
            return 'Full Stack Developer'
        else:
            return 'Developer'
    
    def _determine_effort(self, task_item: Dict) -> str:
        """Determine effort based on priority and description complexity"""
        priority = task_item.get('priority', 'medium')
        description = task_item.get('description', '')
        details = task_item.get('details', '')
        
        # Calculate complexity based on content length and keywords
        total_content = f"{description} {details}"
        content_length = len(total_content)
        
        complexity_keywords = ['implement', 'create', 'setup', 'configure', 'develop', 'build']
        keyword_count = sum(1 for keyword in complexity_keywords if keyword in total_content.lower())
        
        # Determine effort based on multiple factors
        if priority == 'high' and (content_length > 1000 or keyword_count > 5):
            return 'large'
        elif priority == 'high' or (content_length > 500 and keyword_count > 3):
            return 'medium'
        elif priority == 'low' or content_length < 200:
            return 'small'
        else:
            return 'medium'
    
    def estimate_duration(self, effort: str) -> int:
        """Convert effort estimate to days"""
        effort_lower = effort.lower()
        
        # Look for number patterns first
        number_match = re.search(r'(\d+)\s*(day|hour)', effort_lower)
        if number_match:
            num = int(number_match.group(1))
            unit = number_match.group(2)
            return num if unit == 'day' else max(1, num // 8)  # 8 hours = 1 day
        
        # Use effort mapping
        for key, days in self.effort_mapping.items():
            if key in effort_lower:
                return days
        
        return 3  # Default to 3 days

class GanttGenerator:
    """Generate Gantt chart from parsed tasks"""
    
    def __init__(self, tasks: List[Task]):
        self.tasks = tasks
        self.task_map = {task.id: task for task in tasks}
        self.start_date = datetime.now()
    
    def calculate_schedule(self):
        """Calculate start and end dates for all tasks based on dependencies"""
        scheduled = set()
        
        def schedule_task(task: Task, current_date: datetime = None):
            if task.id in scheduled:
                return
            
            if current_date is None:
                current_date = self.start_date
            
            # Schedule all dependencies first
            latest_dependency_end = current_date
            for dep_id in task.dependencies:
                if dep_id in self.task_map:
                    dep_task = self.task_map[dep_id]
                    if dep_task.id not in scheduled:
                        schedule_task(dep_task, current_date)
                    if dep_task.end_date and dep_task.end_date > latest_dependency_end:
                        latest_dependency_end = dep_task.end_date
            
            # Schedule this task
            task.duration_days = self.estimate_duration(task.effort, task.priority)
            task.start_date = latest_dependency_end
            task.end_date = task.start_date + timedelta(days=task.duration_days)
            scheduled.add(task.id)
        
        # Schedule all tasks
        for task in self.tasks:
            schedule_task(task)
    
    def estimate_duration(self, effort: str, priority: str) -> int:
        """Convert effort estimate to days, considering priority"""
        effort_lower = effort.lower()
        priority_lower = priority.lower()
        
        # Base duration mapping
        duration_map = {
            'small': 2,
            'medium': 5,
            'large': 10,
            'extra large': 15,
            'xl': 15
        }
        
        # Get base duration
        base_duration = duration_map.get(effort_lower, 5)
        
        # Adjust based on priority
        if priority_lower == 'high':
            # High priority tasks might need more thorough work
            base_duration = int(base_duration * 1.2)
        elif priority_lower == 'low':
            # Low priority tasks might be simpler
            base_duration = int(base_duration * 0.8)
        
        return max(1, base_duration)  # Minimum 1 day
    
    def create_gantt_chart(self) -> go.Figure:
        """Create interactive Gantt chart using Plotly"""
        self.calculate_schedule()
        
        # Prepare data for Plotly
        df_data = []
        colors = px.colors.qualitative.Set3
        
        # Color mapping for team roles
        team_colors = {}
        unique_assignees = list(set(task.assigned_to for task in self.tasks))
        for i, assignee in enumerate(unique_assignees):
            team_colors[assignee] = colors[i % len(colors)]
        
        for task in self.tasks:
            df_data.append({
                'Task': task.name,
                'Start': task.start_date,
                'Finish': task.end_date,
                'Duration': task.duration_days,
                'Assigned_To': task.assigned_to,
                'Description': task.description,
                'Dependencies': ', '.join([str(dep) for dep in task.dependencies]) if task.dependencies else 'None',
                'Effort': task.effort,
                'Priority': task.priority,
                'Status': task.status,
                'Color': team_colors.get(task.assigned_to, colors[0])
            })
        
        df = pd.DataFrame(df_data)
        
        # Create Gantt chart
        fig = go.Figure()
        
        for i, row in df.iterrows():
            fig.add_trace(go.Scatter(
                x=[row['Start'], row['Finish']],
                y=[i, i],
                mode='lines+markers',
                line=dict(color=row['Color'], width=20),
                marker=dict(size=8, color=row['Color']),
                name=row['Assigned_To'],
                text=row['Task'],
                hovertemplate=(
                    "<b>%{text}</b><br>"
                    "Assigned to: " + row['Assigned_To'] + "<br>"
                    "Duration: " + str(row['Duration']) + " days<br>"
                    "Effort: " + row['Effort'] + "<br>"
                    "Priority: " + row['Priority'] + "<br>"
                    "Status: " + row['Status'] + "<br>"
                    "Dependencies: " + row['Dependencies'] + "<br>"
                    "Description: " + row['Description'][:100] + "..." if len(row['Description']) > 100 else row['Description'] + "<br>"
                    "Start: %{x}<br>"
                    "<extra></extra>"
                ),
                showlegend=i == 0 or row['Assigned_To'] not in [df.iloc[j]['Assigned_To'] for j in range(i)]
            ))
        
        # Update layout
        fig.update_layout(
            title='Project Gantt Chart',
            xaxis_title='Timeline',
            yaxis_title='Tasks',
            yaxis=dict(
                tickmode='array',
                tickvals=list(range(len(df))),
                ticktext=[f"{row['Task'][:50]}..." if len(row['Task']) > 50 else row['Task'] for _, row in df.iterrows()],
                autorange='reversed'
            ),
            height=max(600, len(df) * 40),
            showlegend=True,
            hovermode='x unified'
        )
        
        return fig
    
    def save_html(self, filename: str):
        """Save Gantt chart as HTML file"""
        fig = self.create_gantt_chart()
        fig.write_html(filename)
        print(f"Gantt chart saved to {filename}")

def main():
    parser = argparse.ArgumentParser(description='Generate Gantt chart from task-master.dev output')
    parser.add_argument('input_file', help='Input tasks file (markdown format)')
    parser.add_argument('output_file', help='Output HTML file for Gantt chart')
    
    args = parser.parse_args()
    
    try:
        # Read input file
        with open(args.input_file, 'r', encoding='utf-8') as f:
            content = f.read()
        
        # Parse tasks
        task_parser = TaskParser()
        tasks = task_parser.parse_tasks_from_json(content)
        
        if not tasks:
            print("No tasks found in the input file")
            return
        
        print(f"Found {len(tasks)} tasks")
        
        # Generate Gantt chart
        gantt_gen = GanttGenerator(tasks)
        gantt_gen.save_html(args.output_file)
        
    except FileNotFoundError:
        print(f"Error: Input file '{args.input_file}' not found")
        sys.exit(1)
    except Exception as e:
        print(f"Error: {e}")
        sys.exit(1)

if __name__ == "__main__":
    main()